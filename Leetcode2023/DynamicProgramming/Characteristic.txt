WHERE GREEDY PEOPLE FAIL - DYNAMIC PROGRAMMING WILL FLOURISH AND RULE!

Key Notes:
1. Globally Optimal solutions - Instead of locally optimal solution, consider all choices.
2. Subproblem down - Think of the smallest solvable problem!
3. Overlapping sub-problems - Chache where you can! O(2^n) -> O(n)
4. Reach very Deep decision junctions - To reach the optimial solution via sub-problems
5. Reduce the number of decisions to be made - use the cached knowledge.
6. Top-Down DP: Global Subproblem Break down to--> Base cases [normally recursive] -- "Recurrence in code" -- Recursively follow the recurrence untill the base case, then build back up caching all the way
7. Bottom-Up DP: Know your Base cases to form--> Global subproblem [normally iterative] -- "Rides up the cache" - Force otptimality from the bottom and reach global otpimality
8. Solve, Solve, Solve and given the knowledge back.
9. Narrow minded greedy solutions might word in some-cases, but aren't dependable.
10. The more information you have the easier your life is



1. IDENTIFYING THE RECURRENCE
How do we solve from the global sub-problem and coming downwards...
When is an answer ceratin? What can I keep as my blue-print for decision making?
This helps us in fixating what are my sub-problems?
How do they relate together?
What are my base-cases?

    

